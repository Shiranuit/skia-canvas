//
// Windows & event handling
//

"use strict"

const {EventEmitter} = require('events'),
      {RustClass, core, inspect, neon, REPR} = require('./neon'),
      {Canvas} = require('./canvas'),
      css = require('./css')

const pformat = (obj, depth=999) => inspect(obj, {depth, colors:true}),
      pprint = (obj, depth=999) => process.stdout.write(pformat(obj, depth)+"\n")

const checkSupport = () => {
  if (!neon.App) throw new Error("Skia Canvas was compiled without window support")
}

class App extends RustClass{
  static #locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE
  #events = 'native'
  #launched = false // whether the `eventLoop` property is permanently set
  #running = false // whether launch() can be called to start/resume the event loop
  #fps = 60

  constructor(){
    super(App)
  }

  get windows(){ return [...GUI.windows] }
  get running(){ return this.#launched }
  get eventLoop(){ return this.#events }
  set eventLoop(mode){
    if (this.#launched) throw new Error("Cannot alter event loop after it has begun")
    if (['native', 'node'].includes(mode) && mode != this.#events){
      this.#events = this.ƒ("setMode", mode)
    }
  }
  get fps(){ return this.#fps }
  set fps(rate){
    checkSupport()
    if (rate >= 1 && rate != this.#fps){
      this.#fps = this.ƒ('setRate', rate)
    }
  }

  dispatch({ui, state, geom}){
    // merge autogenerated window locations into newly opened windows
    if (geom) for (const [id, {top, left}] of Object.entries(geom)){
      GUI.getWindow(id, win => {
        win.left = win.left || left
        win.top = win.top || top
      })
    }

    // drop closed windows and update state of active ones
    if (state) GUI.pruneWindows(win =>
      win.top === undefined || // keep new windows still waiting for a `geom` roundtrip
      win.state.id in state && // evict old windows that have been closed
      Object.assign(win, state[win.state.id]) // update local state based on gui interactions
    )

    // deliver ui events to corresponding windows
    if (ui) for (const [id, events] of Object.entries(ui)){
      GUI.getWindow(id, (win, frame) => {
        let modifiers = {}
        for (const [[type, e]] of events.map(o => Object.entries(o))){
          switch(type){
            case 'modifiers':
              var {control_key:ctrlKey, alt_key:altKey, super_key:metaKey, shift_key:shiftKey} = e
              modifiers = {ctrlKey, altKey, metaKey, shiftKey}
            break

            case 'mouse':
              var {button, x, y, pageX, pageY} = e
              e.events.forEach(type => win.emit(type, {x, y, pageX, pageY, button, ...modifiers}))
            break

            case 'input':
              win.emit(type, {data:e, inputType:'insertText'})
            break

            case 'composition':
              win.emit(e.event, {data:e.data, locale:App.#locale})
            break

            case 'keyboard':
              var {event, key, code, location, repeat} = e,
                  defaults = true;

              win.emit(event, {key, code, location, repeat, ...modifiers,
                preventDefault:() => defaults = false
              })

              // apply default keybindings unless e.preventDefault() was run
              if (defaults && event=='keydown' && !repeat){
                let {ctrlKey, altKey, metaKey} = modifiers
                if ( (metaKey && key=='w') || (ctrlKey && key=='c') || (altKey && key=='F4') ){
                  win.close()
                }else if ( (metaKey && key=='f') || (altKey && key=='F8') ){
                  win.fullscreen = !win.fullscreen
                }
              }
            break

            case 'focus':
              if (e) win.emit('focus')
              else win.emit('blur')
            break

            case 'resize':
              if (win.fit == 'resize'){
                win.ctx.prop('size', e.width, e.height)
                win.canvas.prop('width', e.width)
                win.canvas.prop('height', e.height)
              }
              win.emit(type, e)
            break

            case 'move':
            case 'wheel':
              win.emit(type, e)
            break

            case 'fullscreen':
              win.emit(type, {enabled: e})
            break

            default:
              console.log(type, e);
          }
        }
      })
    }

    // provide frame updates to prompt redraws
    GUI.incrementFrameCounters((win, frame) => {
      if (frame==0) win.emit("setup")
      win.emit("frame", {frame})
      if (win.listenerCount('draw')){
        win.canvas.getContext("2d").reset()
        win.emit("draw", {frame})
      }
    })

    // refresh lazily if not doing a flipbook animation
    this.ƒ('setRate', GUI.needsFrameUpdates() ? this.#fps : 0)
  }

  launch(){
    checkSupport()
    clearImmediate(GUI.launcher)
    this.#launched = true
    if (this.#running) return console.error('Application is already running')
    this.#running = true

    this.#render(args => {
      this.dispatch(JSON.parse(args))
      return [
        JSON.stringify( GUI.windows.map(win => win.state) ),
        GUI.windows.map(win => core(win.canvas.pages[win.page-1]) )
      ]
    })
  }

  #render(roundtrip){
    let start = new Date(),
        dt = 1000/this.#fps,
        active = this.ƒ('activate', roundtrip)

    if (active || this.eventLoop=='node'){
      // schedule next frame update if there are still active windows or a event loop is node-based
      // (in which case it can keep running even without windows but unref'd to allow process to exit)
      GUI.frameTimer = setTimeout(() => this.#render(roundtrip), Math.max(0, start + dt - new Date()))
      if (this.eventLoop=='node' && !active) GUI.frameTimer.unref()
    }else{
      // for native event loop with no remaining windows, await a new window + launch() before resuming
      this.#running = false
      GUI.launcher = null
    }
  }

  quit(){
    this.ƒ("quit")
  }

  [REPR](depth, options) {
    let {eventLoop, fps, windows} = this
    return `App ${inspect({eventLoop, fps, windows}, Object.assign(options, {
      depth:1, customInspect:false
    }))}`
  }
}

// Mix the EventEmitter properties into App
Object.assign(App.prototype, EventEmitter.prototype)


class Window extends EventEmitter{
  static #kwargs = "id,left,top,width,height,title,page,background,fullscreen,cursor,fit,visible,resizable".split(/,/)
  static #nextID = 1
  #canvas
  #state

  // accept either ƒ(width, height, {…}) or ƒ({…})
  constructor(width=512, height=512, opts={}){
    checkSupport()

    if (!Number.isFinite(width) || !Number.isFinite(height)){
      opts = [...arguments].slice(-1)[0] || {}
      width = opts.width || (opts.canvas || {}).width || 512
      height = opts.height || (opts.canvas || {}).height || 512
    }

    let canvas = (opts.canvas instanceof Canvas) ? opts.canvas : new Canvas(width, height)

    super(Window)
    this.#state = {
      title: "",
      visible: true,
      resizable: true,
      background: "white",
      fullscreen: false,
      page: canvas.pages.length,
      left: undefined,
      top: undefined,
      width,
      height,
      cursor: "default",
      cursorHidden: false,
      fit: "contain",
      id: `${Window.#nextID++}`
    }

    Object.assign(this, {canvas}, Object.fromEntries(
      Object.entries(opts).filter(([k, v]) => Window.#kwargs.includes(k) && v!==undefined)
    ))

    GUI.openWindow(this)
  }

  get state(){ return {...this.#state} }
  get ctx(){ return this.#canvas.pages[this.page-1] }
  get id(){ return +this.#state.id }
  set id(_){ /* immutable*/ }

  get canvas(){ return this.#canvas }
  set canvas(canvas){
    if (canvas instanceof Canvas){
      canvas.getContext("2d") // ensure it has at least one page
      this.#canvas = canvas
      this.#state.page = canvas.pages.length
    }
  }

  get visible(){ return this.#state.visible }
  set visible(flag){ this.#state.visible = !!flag }

  get resizable(){ return this.#state.resizable }
  set resizable(flag){ this.#state.resizable = !!flag }

  get fullscreen(){ return this.#state.fullscreen }
  set fullscreen(flag){ this.#state.fullscreen = !!flag }

  get title(){ return this.#state.title }
  set title(txt){ this.#state.title = (txt != null ? txt : '').toString() }

  get cursor(){ return this.#state.cursorHidden ? 'none' : this.#state.cursor }
  set cursor(icon){
    if (css.cursor(icon)){
      this.#state.cursorHidden = icon == 'none'
      if (icon != 'none') this.#state.cursor = icon
    }
  }

  get fit(){ return this.#state.fit }
  set fit(mode){ if (css.fit(mode)) this.#state.fit = mode }

  get left(){ return this.#state.left }
  set left(val){ if (Number.isFinite(val)) this.#state.left = val }

  get top(){ return this.#state.top }
  set top(val){ if (Number.isFinite(val)) this.#state.top = val }

  get width(){ return this.#state.width }
  set width(val){ if (Number.isFinite(val)) this.#state.width = val }

  get height(){ return this.#state.height }
  set height(val){ if (Number.isFinite(val)) this.#state.height = val }

  get page(){ return this.#state.page }
  set page(val){
    if (val < 0) val += this.#canvas.pages.length + 1
    let page = this.#canvas.pages[val-1]
    if (page && this.#state.page != val){
      let [width, height] = page.prop('size')
      this.#canvas.prop('width', width)
      this.#canvas.prop('height', height)
      this.#state.page = val
    }
  }

  get background(){ return this.#state.background }
  set background(c){ this.#state.background = (c != null ? c : '').toString() }

  emit(type, e){
    // report errors in event-handlers but don't crash
    try{ super.emit(type, Object.assign({target:this, type}, e)) }
    catch(err){ console.error(err) }
  }

  close(){ GUI.closeWindow(this) }

  [REPR](depth, options) {
    let info = Object.fromEntries(Window.#kwargs.map(k => [k, this[k]]))
    return `Window ${inspect(info, options)}`
  }
}

const GUI = {
  App: new App(),
  windows: [],
  frames: new WeakMap(),
  launcher: null,
  frameTimer: null,

  incrementFrameCounters(callback){
    GUI.windows.forEach(win => {
      let frame = GUI.frames.get(win) || 0
      GUI.frames.set(win, frame + 1)
      callback(win, frame)
    })
  },

  needsFrameUpdates(){
    let names = GUI.windows.map(win => win.eventNames()).flat()
    return (names.includes('frame') || names.includes('draw'))
  },

  getWindow(id, callback){
    GUI.windows.filter(w => w.state.id==id).forEach(win => callback(win))
  },

  openWindow(win){
    GUI.windows.push(win)
    GUI.App.emit('open', win)
    if (!GUI.launcher) GUI.launcher = setImmediate( () => GUI.App.launch() )
    else if (GUI.frameTimer) GUI.frameTimer.ref() // stay alive until window can open
    neon.App.openWindow(JSON.stringify(win.state), core(win.canvas.pages[win.state.page-1]))
  },

  closeWindow(win){
    GUI.pruneWindows(w => w!==win)
    neon.App.closeWindow(win.state.id)
  },

  pruneWindows(keep){
    GUI.windows
      .filter(w => !keep(w))
      .map(win => GUI.App.emit('close', win))
    GUI.windows = GUI.windows.filter(keep)
  }
}

module.exports = {App:GUI.App, Window}
